
/******************************************************************************
*
*   FILE
*   ----
*   SQLite3.c
*
*   History
*   -------
*   2018-04-25   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_Databases
#define OV_COMPILE_LIBRARY_Databases
#endif


#include "Databases.h"
#include "libov/ov_macros.h"
#include "sqlite3.h"
#include "libov/ov_logfile.h"
#include <stdio.h>



// global variables, access to object members and db handler
OV_INSTPTR_Databases_SQLite3 SQLITE3_pinst = NULL;
int rc;
sqlite3* db;

// callback function
static int callback(void* data, int argc, char **argv, char **col_name) {
	for(int i = 0; i<argc; i++) {
		ov_logfile_info("%-10s : %-s", col_name[i], argv[i] ? argv[i] : "NULL");
	}
	return 0;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_connect(void) {
	//if(SQLITE3_pinst->v_Endpoint == NULL) return OV_ERR_BADPARAM;
	ov_logfile_info("%s", SQLITE3_pinst->v_Endpoint);
	rc = sqlite3_open(SQLITE3_pinst->v_Endpoint , &db);
	if( rc != SQLITE_OK ) {
		ov_logfile_info("failed to open db!");
		sqlite3_close(db);
		return OV_ERR_GENERIC;
	}
	// TEST
	OV_STRING table = "register";
	OV_STRING fields[] = {"ip"};
	OV_STRING values[] = {"192.168.0.1"};
	Databases_SQLite3_deleteData(table, fields, values);
	// TEST
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_disconnect(void) {

	sqlite3_close(db);

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_insertData(const OV_STRING table, const OV_STRING* fields, const OV_STRING* values) {
    // TODO length of fields, 2 is bad!
	int len = sizeof(fields)/2;
	// build up INSERT query

	char* query = "INSERT INTO ";
	asprintf(&query, "%s%s ", query, table);
	asprintf(&query, "%s%s", query, "(");
	for(int i = 0; i < len; i++) {
		if(i == len-1) {
			asprintf(&query, "%s%s) ", query, fields[i]);
		} else {
			asprintf(&query, "%s%s, ", query, fields[i]);
		}
	}
	asprintf(&query, "%s%s", query, "VALUES (");
	for(int i = 0; i < len; i++) {
		if(i == len-1) {
			asprintf(&query, "%s%s); ", query, values[i]);
		} else {
			asprintf(&query, "%s%s, ", query, values[i]);
		}
	}
	ov_logfile_info("%s", query);

	sqlite3_stmt *stmt;
	sqlite3_prepare_v2(db, query, -1,  &stmt, NULL);

	rc = sqlite3_step(stmt);
	if( rc != SQLITE_DONE ) {
		ov_logfile_info("error: failed to insert into %s", table);
		return OV_ERR_BADPARAM;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_selectData(const OV_STRING table, const OV_STRING* fields, const OV_STRING* whereFields, OV_STRING* whereValues) {
    // length of fields
	int lenFields, lenWhereFields;
	lenFields = lenWhereFields = 0;

	if(fields != NULL)
		lenFields = sizeof(fields)/2;
	if(whereFields != NULL)
		lenWhereFields = sizeof(whereFields)/2;

	// build up SELECT query
	char* query = "SELECT ";
	for(int i = 0; i < lenFields; i++) {
		if(i != lenFields-1) {
			asprintf(&query, "%s %s, ", query, fields[i]);
		} else {
			asprintf(&query, "%s %s ", query, fields[i]);
		}
	}
	if(!lenFields) asprintf(&query, "%s %s ", query, "*");
	asprintf(&query, "%s%s", query, "FROM ");
	asprintf(&query, "%s%s", query, table);
	if(lenWhereFields) {
		asprintf(&query, "%s%s", query, "WHERE ");
		for(int i = 0; i < lenWhereFields; i++) {
			if(i != lenWhereFields-1) {
				asprintf(&query, " %s%s = ", query, whereFields[i]);
				asprintf(&query, "%s%s, ", query, whereValues[i]);
			} else {
				asprintf(&query, " %s%s = ", query, whereFields[i]);
				asprintf(&query, "%s%s ", query, whereValues[i]);
			}
		}
	}
	asprintf(&query, "%s%s", query, ";");

	ov_logfile_info("%s", query);

	char* err_msg;
	rc = sqlite3_exec(db, query, callback, NULL, &err_msg);

	if(rc != SQLITE_OK) {
		ov_logfile_info("SQL Error: %s", err_msg);
		sqlite3_free(err_msg);
		return OV_ERR_BADPARAM;
	}
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_deleteData(const OV_STRING table, const OV_STRING* fields, const OV_STRING* values) {
    // TODO length of fields, 2 is bad!
	int len = 0;
	if(fields != NULL) {
		len = sizeof(fields)/2;
	}
	// build up INSERT query

	char* query = "DELETE FROM ";
	asprintf(&query, "%s%s ", query, table);
	if(len) {
		asprintf(&query, "%s%s ", query, "WHERE");
		for(int i = 0; i < len; i++) {
			if(i != len-1) {
				asprintf(&query, "%s%s = ", query, fields[i]);
				asprintf(&query, "%s%s, ", query, values[i]);
			} else {
				asprintf(&query, "%s%s = ", query, fields[i]);
				asprintf(&query, "%s%s", query, values[i]);
			}
		}
	}
	asprintf(&query, "%s%s", query, ";");

	ov_logfile_info("%s", query);

	sqlite3_stmt *stmt;
	sqlite3_prepare_v2(db, query, -1,  &stmt, NULL);

	rc = sqlite3_step(stmt);
	if( rc != SQLITE_DONE ) {
		ov_logfile_info("error: failed to insert into %s", table);
		return OV_ERR_BADPARAM;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_execQuery(const OV_STRING query) {

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_query_set(
    OV_INSTPTR_Databases_SQLite3          pobj,
    const OV_STRING  value
) {
	const char* data = "Callback funtion called";
	char* err_msg;

    ov_string_setvalue(&pobj->v_query,value);
    ov_logfile_info("%s", pobj->v_query);
	rc = sqlite3_exec(db, pobj->v_query, callback, (void*)data, &err_msg);

	if( rc != SQLITE_DONE ) {
		ov_logfile_info("SQL error: %s", err_msg);
		return OV_ERR_GENERIC;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_io_set(
    OV_INSTPTR_Databases_SQLite3          pobj,
    const OV_BOOL  value
) {
	pobj->v_io = value;
/*
	if(pobj->v_io) {
		Databases_SQLite3_readData();
	}
	else {
		Databases_SQLite3_writeData();
	}*/

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_Databases_SQLite3 pinst = Ov_StaticPtrCast(Databases_SQLite3, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = openAASDiscoveryServer_DBWrapper_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    SQLITE3_pinst = pinst;
    return OV_ERR_OK;
}

