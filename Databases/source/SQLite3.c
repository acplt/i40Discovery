
/******************************************************************************
*
*   FILE
*   ----
*   SQLite3.c
*
*   History
*   -------
*   2018-04-25   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_Databases
#define OV_COMPILE_LIBRARY_Databases
#endif


#include "Databases.h"
#include "libov/ov_macros.h"
#include "sqlite3.h"
#include "libov/ov_logfile.h"
#include <stdio.h>



// global variables, access to object members and db handler
OV_INSTPTR_Databases_SQLite3 SQLITE3_pinst = NULL;
int rc;

// callback function
static int callback(void* data, int argc, char **argv, char **col_name) {
	Ov_SetDynamicVectorLength((OV_STRING_VEC*)data, argc, STRING);

	for(int i = 0; i<argc; i++) {
		ov_string_setvalue(&(((OV_STRING_VEC*)data)->value[i]), argv[i]);
		ov_logfile_info("%-10s : %-s", col_name[i], argv[i] ? argv[i] : "NULL");
	}
	return 0;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_connect(void) {
	//if(SQLITE3_pinst->v_Endpoint == NULL) return OV_ERR_BADPARAM;
	ov_logfile_info("connecting to : %s", SQLITE3_pinst->v_Endpoint);
	rc = sqlite3_open(SQLITE3_pinst->v_Endpoint , &SQLITE3_pinst->v_db);
	if( rc != SQLITE_OK) {
		ov_logfile_info("failed to open db!");
		sqlite3_close(SQLITE3_pinst->v_db);
		return OV_ERR_GENERIC;
	}
	OV_STRING table  = "demoDB";
	OV_STRING fields[1] = {"SecurityKey"};
	OV_STRING whereFields[1] = {"ComponentID"};
	OV_STRING whereValues[1] = {"'test'"};
	OV_STRING_VEC result;
	result.value = NULL;
	result.veclen = 0;
	Databases_SQLite3_selectData(table, fields, 1, whereFields, 1, whereValues, 1, &result);
	for(int i = 0; i < result.veclen; i++) {
		ov_logfile_info("%s ", result.value[i]);
	}
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_disconnect(void) {
	sqlite3_close(SQLITE3_pinst->v_db);

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_insertData(const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen,
													   const OV_STRING* values, OV_UINT valuesLen) {
	if(fieldsLen != valuesLen) {
		return OV_ERR_BADPARAM;
	}
	// build up INSERT query
	char* query = "INSERT INTO ";
	asprintf(&query, "%s%s ", query, table);
	asprintf(&query, "%s%s", query, "(");
	for(int i = 0; i < fieldsLen; i++) {
		if(i == fieldsLen-1) {
			asprintf(&query, "%s%s) ", query, fields[i]);
		} else {
			asprintf(&query, "%s%s, ", query, fields[i]);
		}
	}
	asprintf(&query, "%s%s", query, "VALUES (");
	for(int i = 0; i < fieldsLen; i++) {
		if(i == fieldsLen-1) {
			asprintf(&query, "%s%s); ", query, values[i]);
		} else {
			asprintf(&query, "%s%s, ", query, values[i]);
		}
	}
	ov_logfile_info("%s", query);

	sqlite3_stmt *stmt;
	sqlite3_prepare_v2(SQLITE3_pinst->v_db, query, -1,  &stmt, NULL);

	rc = sqlite3_step(stmt);
	if( rc == SQLITE_ERROR ) {
		ov_logfile_info("error: failed to insert into %s", table);
		return OV_ERR_BADPARAM;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_selectData(const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* whereFields,
													   OV_UINT whereFieldsLen, OV_STRING* whereValues, OV_UINT whereValuesLen, OV_STRING_VEC* result) {
	if(whereFieldsLen != whereValuesLen) {
		return OV_ERR_BADPARAM;
	}
	// build up SELECT query
	char* query = "SELECT";
	for(int i = 0; i < fieldsLen; i++) {
		if(i != fieldsLen-1) {
			asprintf(&query, "%s %s,", query, fields[i]);
		} else {
			asprintf(&query, "%s %s", query, fields[i]);
		}
	}
	if(!fieldsLen) asprintf(&query, "%s %s ", query, "*");
	asprintf(&query, "%s %s", query, "FROM");
	asprintf(&query, "%s %s", query, table);
	if(whereFieldsLen) {
		asprintf(&query, "%s %s", query, "WHERE");
		for(int i = 0; i < whereFieldsLen; i++) {
			if(i != whereFieldsLen-1) {
				asprintf(&query, "%s %s =", query, whereFields[i]);
				asprintf(&query, "%s %s,", query, whereValues[i]);
			} else {
				asprintf(&query, "%s %s =", query, whereFields[i]);
				asprintf(&query, "%s %s", query, whereValues[i]);
			}
		}
	}
	asprintf(&query, "%s%s", query, ";");

	ov_logfile_info("%s", query);

	char* err_msg;
	rc = sqlite3_exec(SQLITE3_pinst->v_db, query, callback, result, &err_msg);

	if(rc != SQLITE_OK) {
		ov_logfile_info("SQL Error: %s", err_msg);
		sqlite3_free(err_msg);
		return OV_ERR_BADPARAM;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_deleteData(const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* values, OV_UINT valuesLen) {
	// build up DELETE query
	char* query = "DELETE FROM ";
	asprintf(&query, "%s%s ", query, table);
	if(fieldsLen) {
		asprintf(&query, "%s%s ", query, "WHERE");
		for(int i = 0; i < fieldsLen; i++) {
			if(i != fieldsLen-1) {
				asprintf(&query, "%s%s = ", query, fields[i]);
				asprintf(&query, "%s%s, ", query, values[i]);
			} else {
				asprintf(&query, "%s%s = ", query, fields[i]);
				asprintf(&query, "%s%s", query, values[i]);
			}
		}
	}
	asprintf(&query, "%s%s", query, ";");

	ov_logfile_info("%s", query);

	sqlite3_stmt *stmt;
	sqlite3_prepare_v2(SQLITE3_pinst->v_db, query, -1,  &stmt, NULL);

	rc = sqlite3_step(stmt);
	if( rc != SQLITE_DONE ) {
		ov_logfile_info("error: failed to insert into %s", table);
		return OV_ERR_BADPARAM;
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_execQuery(const OV_STRING query) {

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_query_set(
    OV_INSTPTR_Databases_SQLite3          pobj,
    const OV_STRING  value
) {
	if(!value) {
		const char* data = "Callback funtion called";
		char* err_msg = NULL;

		ov_string_setvalue(&pobj->v_query,value);
		ov_logfile_info("%s", pobj->v_query);
		rc = sqlite3_exec(SQLITE3_pinst->v_db, pobj->v_query, callback, (void*)data, &err_msg);

		if( rc != SQLITE_DONE ) {
			ov_logfile_info("SQL error: %s", err_msg);
			return OV_ERR_GENERIC;
		}
	}

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_io_set(
    OV_INSTPTR_Databases_SQLite3          pobj,
    const OV_BOOL  value
) {
	pobj->v_io = value;
/*
	if(pobj->v_io) {
		Databases_SQLite3_readData();
	}
	else {
		Databases_SQLite3_writeData();
	}*/

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLite3_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_Databases_SQLite3 pinst = Ov_StaticPtrCast(Databases_SQLite3, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = openAASDiscoveryServer_DBWrapper_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    SQLITE3_pinst = pinst;
    return OV_ERR_OK;
}

